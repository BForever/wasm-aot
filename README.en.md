# WASM-AoT



## Introduction

An AOT runtime that can run wasm in AVR architecture



## Software architecture

### libs

Third party Libraries

Including Avrora simulator

### include

Header files

### src

core runtime code

### app

Wasm sample application code
including benchmarks


## Installation tutorial

1. Possible dependencies (Ubuntu system)

```
apt install git build-essential wget curl unzip python3 gcc-multilib xxd cmake wabt
apt install gcc-avr avr-libc avrdude gdb-avr openjdk-11-jdk
```

## Instructions for use

1. Compile wasm code [optional]

First write your `test.wat` file (writing wasm code directly in text format to facilitate debugging)

Then use the following command to convert it to `.h` file format(c header file)

```
wat2wasm test. wat -o test. wasm --enable-annotations -v
wasm2wat test. wasm -o testi. wat
xxd -i test. wasm > test. wasm. h
```

The additional parameters in the first command make it easy to view the details of wasm binary format

The second command reverses the conversion from binary format to text format, which can be used to verify the correctness of manually written code

To test whether the `.wat` file is correct, run `python3 instance.py` under `app/wasmer-test` directory
(dependency: `pip install wasmer wasmer_compiler_cranelift`)

You can view the results directly.

If there is an `import` function in `.wat` file, please add it in `instance.py`.

2. Compile code

Execute the following shell command in the root directory:

```
rm -rf build
mkdir build&&cd build
cmake ..
make
```

3. Run in simulator

Execute the following shell command in the root directory:

```
cd libs
sh test.sh
```

## Run benchmark

1. Compile benchmark

Run in the `app/benchmark` folder

```
bash compile.sh
```

The script will automatically compile the benchmark (from C code to native elf and wasm files)

2. Run benchmark

Run in the `libs` directory

```
bash wasmbench.sh
```

You can automatically run all wasm files generated by the previous compilation and output the results to `[benchname].wasmoutput.txt` file

3. Run benchmark in native c

Run in the `libs` directory

```
bash nativebench.sh
```

You can automatically run all elf files generated in the first step of compilation and output the results to `[benchneme].nativeoutput.txt` file, which is used to compare the running efficiency of runtime

#### Contribution

1.  Fork the repository
2.  Create Feat_xxx branch
3.  Commit your code
4.  Create Pull Request
